import React, { useEffect, useMemo, useCallback, useState } from 'react'
import { useGame } from './useGame'
import { PAYTABLE_8_5 } from './payout'
import BankPanel from './BankPanel'
import './styles.css'

// (kept from your file, in case you use it elsewhere)
function rankShort(rank: string) { return rank === '10' ? '10' : rank[0] }

const ORDER: (keyof typeof PAYTABLE_8_5)[] = [
  'Royal Flush','Straight Flush','Four of a Kind','Full House',
  'Flush','Straight','Three of a Kind','Two Pair','Jacks or Better'
]

// Map rank/suit → filename part in /public/cards
function mapCardToFile(rank: string, suit: string): string {
  let rankName = ''
  switch(rank) {
    case 'A': rankName = 'ace'; break
    case 'J': rankName = 'jack'; break
    case 'Q': rankName = 'queen'; break
    case 'K': rankName = 'king'; break
    default:  rankName = rank.toLowerCase(); break  // 2–10
  }
  const suitName =
    suit === '♠' ? 'spades' :
    suit === '♥' ? 'hearts' :
    suit === '♦' ? 'diamonds' : 'clubs'
  return `${rankName}_of_${suitName}.svg`
}

/* =========================
   Cache warm-up helpers
   ========================= */
const RANKS = ['A','K','Q','J','10','9','8','7','6','5','4','3','2']
const SUITS: Array<'♠'|'♥'|'♦'|'♣'> = ['♠','♥','♦','♣']

function allCardUrls(): string[] {
  const urls: string[] = []
  for (const r of RANKS) for (const s of SUITS) {
    urls.push(`/cards/${mapCardToFile(r, s)}`)
  }
  return urls
}

// Cross-browser idle callback
const ric: (cb: () => void) => void =
  (typeof window !== 'undefined' && (window as any).requestIdleCallback)
    ? (cb) => (window as any).requestIdleCallback(cb)
    : (cb) => setTimeout(cb, 0)

type CardFaceProps = {
  rank: string
  suit: string
  held: boolean
  onClick: () => void
}

// Memoized to avoid unnecessary re-renders
const CardFace = React.memo(function CardFace({ rank, suit, held, onClick }: CardFaceProps) {
  const fileName = mapCardToFile(rank, suit)
  const alt = `${rank} of ${suit}`

  return (
    <div
      className="card"
      data-held={held ? 'true' : 'false'}
      onClick={onClick}
      role="button"
      aria-pressed={held}
      tabIndex={0}
      onKeyDown={(e) => {
        if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); onClick() }
      }}
      style={{
        position: 'relative',
        borderRadius: 8,
        overflow: 'hidden',
        boxShadow: '2px 4px 8px rgba(0,0,0,0.25)',
        contain: 'content'
      }}
    >
      <img
        src={`/cards/${fileName}`}
        alt={alt}
        style={{ width: '100%', height: '100%', objectFit: 'contain', display: 'block' }}
        width={240} height={360}
        decoding="async"
        loading="eager"
        draggable={false}
        onPointerDown={(e) => {
          // Prevents drag-ghost on iOS long-press
          if ((e as any).pointerType === 'touch') e.preventDefault()
        }}
      />
      {held && <div className="holdTag">HOLD</div>}
    </div>
  )
})

function Paytable({ bet, highlight }: { bet: number; highlight?: keyof typeof PAYTABLE_8_5 | null }) {
  return (
    <table className="paytable">
      <thead>
        <tr>
          <th>Hand</th>
          {[1,2,3,4,5].map(n=>(
            <th key={n} className={n===bet ? 'active' : ''}>Bet {n}</th>
          ))}
        </tr>
      </thead>
      <tbody>
        {ORDER.map(hand=>(
          <tr key={hand} className={highlight === hand ? 'hl' : ''}>
            <td>{hand}</td>
            {PAYTABLE_8_5[hand].map((payout, i)=>(
              <td key={i} className={i+1===bet ? 'active' : ''}>{payout}</td>
            ))}
          </tr>
        ))}
      </tbody>
    </table>
  )
}

export default function App(){
  const g = useGame()

  /* ========= Ask for persistent storage (less eviction on mobile) ========= */
  useEffect(() => {
    (async () => {
      try {
        if ('storage' in navigator && 'persist' in navigator.storage) {
          await (navigator.storage as any).persist?.()
        }
      } catch { /* ignore */ }
    })()
  }, [])

  /* ========= Warm all 52 SVGs in idle-time chunks ========= */
  useEffect(() => {
    let cancelled = false
    const urls = allCardUrls()

    // Be kind on constrained connections / Data Saver
    const conn = (navigator as any)?.connection
    if (conn?.saveData) return

    async function addChunk(start: number, size = 8) {
      if (cancelled) return
      const slice = urls.slice(start, start + size)
      if (!slice.length) return

      try {
        if ('caches' in window) {
          const cache = await caches.open('cards-prewarm-v1')
          await Promise.all(slice.map(u => cache.add(u).catch(()=>{})))
        } else {
          // Fallback warms the HTTP cache
          await Promise.all(slice.map(u => fetch(u, { cache: 'force-cache' }).catch(()=>{})))
        }
      } catch { /* ignore */ }

      if (start + size < urls.length) {
        ric(() => addChunk(start + size, size))
      }
    }

    // Start shortly after first paint so we don't compete with LCP
    const t = setTimeout(() => ric(() => addChunk(0)), 350)
    return () => { cancelled = true; clearTimeout(t) }
  }, [])

  // Preload current hand SVGs (helps Safari/iOS for the immediate next paints)
  useEffect(() => {
    if (!g.hand?.length) return
    const imgs = g.hand.map(c => {
      const img = new Image()
      img.decoding = 'async'
      img.src = `/cards/${mapCardToFile(c.rank, c.suit)}`
      return img
    })
    return () => { imgs.forEach(img => { (img as any).src = '' }) }
  }, [g.hand])

  /* ========= Bet One (cycles 1→5 and wraps to 1) + grey pulse on wrap ========= */
  const [wrapPulse, setWrapPulse] = useState(false)
  const triggerWrapPulse = useCallback(() => {
    // restart animation reliably
    setWrapPulse(false)
    requestAnimationFrame(() => {
      setWrapPulse(true)
      setTimeout(() => setWrapPulse(false), 240)
    })
  }, [])

  const betOne = useCallback(() => {
    const canAdjust = g.phase === 'bet' || g.phase === 'show'
    if (!canAdjust) return
    if (g.bet < 5) {
      g.changeBet(+1)
    } else {
      g.changeBet(-4) // wrap 5 → 1
      triggerWrapPulse()
    }
  }, [g.phase, g.bet, g.changeBet, triggerWrapPulse])

  // Keyboard shortcuts: 1-5 holds, D=Deal/Draw, B=Bet One, M=Max Bet
  useEffect(() => {
    const onKey = (e: KeyboardEvent) => {
      if (e.repeat) return
      const k = e.key.toLowerCase()
      if (k >= '1' && k <= '5') {
        const idx = Number(k) - 1
        if (idx < g.hand.length) g.toggleHold(idx)
      } else if (k === 'd') {
        if (g.canDeal) g.deal()
        else if (g.canDraw) g.draw()
      } else if (k === 'b') {
        betOne()
      } else if (k === 'm') {
        if ((g.phase === 'bet' || g.phase === 'show')) g.setMaxBet()
      }
    }
    window.addEventListener('keydown', onKey)
    return () => window.removeEventListener('keydown', onKey)
  }, [g.hand, g.canDeal, g.canDraw, g.phase, g.toggleHold, g.deal, g.draw, betOne, g.setMaxBet])

  const paytableHighlight = useMemo<keyof typeof PAYTABLE_8_5 | null>(() => {
    return (g.result?.rank as any) || (g.initialRank as any) || null
  }, [g.result?.rank, g.initialRank])

  const canAdjustBet = g.phase === 'bet' || g.phase === 'show'

  return (
    <div className="app">
      <h2 className="title">Video Poker — Jacks or Better (8/5)</h2>

      <div className="layout">
        {/* Game column */}
        <div className="table">
          <div className="row" style={{gap:12}}>
            <div>Credits: <b>{g.credits}</b></div>
            <div>Bet: <b>{g.bet}</b></div>
            <div>Rewards: <b>{g.rewardsPoints}</b></div>
            <div>Accuracy: <b>{g.accCorrect}/{g.accTotal}</b> ({g.accuracyPct}%)</div>
          </div>

          {/* Money controls */}
          <div className="controls" style={{marginTop:8}}>
            <button type="button" onClick={()=>g.insert(1)}>Insert $1</button>
            <button type="button" onClick={()=>g.insert(5)}>Insert $5</button>
            <button type="button" onClick={g.cashOutAll} disabled={g.credits===0}>Cash Out</button>
          </div>

          {/* Betting + actions — Bet One (wraps) + Max Bet */}
          <div className="controls">
            <button
              type="button"
              onClick={betOne}
              disabled={!canAdjustBet}
              className={`betOneBtn ${wrapPulse ? 'is-pulsing' : ''}`}
              aria-label="Bet One (cycles 1 to 5 and wraps to 1)"
            >
              Bet One
            </button>
            <button type="button" onClick={g.setMaxBet} disabled={!canAdjustBet}>Max Bet</button>
            <button type="button" onClick={g.deal} disabled={!g.canDeal}>Deal</button>
            <button type="button" onClick={g.draw} disabled={!g.canDraw}>Draw</button>
          </div>

          {/* Cards */}
          <div className="cards">
            {g.hand.length ? g.hand.map((c, i)=>(
              <CardFace
                key={c.id}
                rank={c.rank}
                suit={c.suit}
                held={g.holds[i]}
                onClick={()=>g.toggleHold(i)}
              />
            )): (
              <p style={{opacity:.7, margin:'16px 0'}}>Tap Deal to begin. Tap cards to HOLD before Draw.</p>
            )}
          </div>

          {/* Outcomes */}
          <div className="payouts" aria-live="polite">
            {g.initialRank && (
              <div style={{marginTop:6}}>
                Initial deal: <b>{g.initialRank}</b>
              </div>
            )}
            {g.result && (
              <div style={{marginTop:6}}>
                Result: <b>{g.result.rank}</b> &nbsp; Payout: <b>{g.result.payout}</b>
              </div>
            )}
          </div>

          {/* Paytable */}
          <Paytable bet={g.bet} highlight={paytableHighlight} />

          <div style={{marginTop:6, opacity:0.8, fontStyle:'italic'}}>
            8/5 Jacks or Better paytable shown above.
          </div>
        </div>

        {/* Side panel */}
        <BankPanel />
      </div>

      {/* Coaching modal */}
      {g.suggestion && (
        <div className="modal" role="dialog" aria-modal="true" aria-label="Trainer suggestion">
          <div className="modalBox">
            <h4>Trainer: A better hold is suggested</h4>
            <p style={{opacity:.85, marginTop:4}}>
              These highlighted cards are the statistically best hold for 8/5 Jacks or Better.
              You have one chance to apply the suggestion this round.
            </p>
            <div className="hintCards">
              {g.hand.map((c, i) => {
                const fileName = mapCardToFile(c.rank, c.suit)
                const keep = g.suggestion![i]
                return (
                  <div key={c.id} className={`hintCard ${keep ? 'keep' : ''}`} title={`${c.rank} ${c.suit}`}>
                    <img
                      src={`/cards/${fileName}`}
                      alt={`${c.rank} of ${c.suit}`}
                      width={120} height={180}
                      decoding="async"
                      loading="lazy"
                      draggable={false}
                      style={{ display:'block', width:'100%', height:'100%', objectFit:'contain' }}
                    />
                  </div>
                )
              })}
            </div>
            <div className="controls" style={{justifyContent:'flex-end'}}>
              <button type="button" onClick={g.acceptSuggestionAndDraw}>Apply &amp; Draw</button>
              <button type="button" onClick={g.keepMineAndDraw}>Keep Mine &amp; Draw</button>
            </div>
          </div>
        </div>
      )}

      <small style={{opacity:.6}}>
        Coaching: you’ll be prompted at most once per round. Correct rounds (no prompt) count toward accuracy; prompted rounds score 0.
      </small>
    </div>
  )
}

