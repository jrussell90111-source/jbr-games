import { useEffect, useState } from 'react'
import { Card, newDeck } from './cards'
import { evaluateHand, type HandRank } from './evaluate'
import { payoutFor } from './payout'

type Phase = 'bet' | 'deal' | 'draw' | 'show'
const COIN_VALUE_DOLLARS = 1

const BANK_KEY = 'bank_balance'
const CREDITS_KEY = 'credits'
const P_IN_KEY = 'bank_in_total'
const P_OUT_KEY= 'bank_out_total'
const REWARDS_KEY = 'rewards_points'
const REWARDS_REM_KEY = 'rewards_remainder'
const ACC_CORRECT_KEY = 'acc_correct'
const ACC_TOTAL_KEY = 'acc_total'

function readNum(key: string, def = 0) {
  const n = Number(localStorage.getItem(key))
  return Number.isFinite(n) ? n : def
}
function writeNum(key: string, val: number) {
  localStorage.setItem(key, String(val))
}

export function useGame() {
  // Credits managed by the game
  const [credits, setCredits] = useState<number>(() => readNum(CREDITS_KEY, 200))
  const [bet, setBet] = useState(1)
  const [deck, setDeck] = useState<Card[]>(newDeck())
  const [hand, setHand] = useState<Card[]>([])
  const [holds, setHolds] = useState<boolean[]>([false,false,false,false,false])
  const [phase, setPhase] = useState<Phase>('bet')
  const [result, setResult] = useState<{rank: HandRank, payout: number} | null>(null)
  const [initialRank, setInitialRank] = useState<HandRank | null>(null)

  // Rewards (summary only)
  const [rewardsPoints, setRewardsPoints] = useState<number>(() => readNum(REWARDS_KEY, 0))
  const [rewardsRemainderDollars, setRewardsRemainderDollars] = useState<number>(() => readNum(REWARDS_REM_KEY, 0))

  // Coaching state
  const [promptedThisRound, setPromptedThisRound] = useState(false)
  const [suggestion, setSuggestion] = useState<boolean[] | null>(null) // recommended holds

  // Accuracy stats
  const [accCorrect, setAccCorrect] = useState<number>(() => readNum(ACC_CORRECT_KEY, 0))
  const [accTotal, setAccTotal] = useState<number>(() => readNum(ACC_TOTAL_KEY, 0))

  // Persist + broadcast
  useEffect(()=>{ 
    writeNum(CREDITS_KEY, credits)
    window.dispatchEvent(new CustomEvent('app:credits', { detail: credits }))
  }, [credits])
  useEffect(()=>{ writeNum(REWARDS_KEY, rewardsPoints); window.dispatchEvent(new Event('app:rewards')) }, [rewardsPoints])
  useEffect(()=>{ writeNum(REWARDS_REM_KEY, rewardsRemainderDollars) }, [rewardsRemainderDollars])
  useEffect(()=>{ writeNum(ACC_CORRECT_KEY, accCorrect) }, [accCorrect])
  useEffect(()=>{ writeNum(ACC_TOTAL_KEY, accTotal) }, [accTotal])

  // (Optional) listen for external credits changes
  useEffect(()=>{
    const onCredits = (e: Event) => {
      const detail = (e as CustomEvent<number>).detail
      if (typeof detail === 'number') setCredits(detail)
    }
    window.addEventListener('app:credits', onCredits as EventListener)
    return () => window.removeEventListener('app:credits', onCredits as EventListener)
  }, [])

  useEffect(()=>{
  const onAccuracy = () => {
    // read the latest values and update state so the UI refreshes immediately
    const c = readNum(ACC_CORRECT_KEY, 0)
    const t = readNum(ACC_TOTAL_KEY, 0)
    setAccCorrect(c)
    setAccTotal(t)
  }
  window.addEventListener('app:accuracy', onAccuracy)
  return () => window.removeEventListener('app:accuracy', onAccuracy)
}, [])

  // UI helpers
  function toggleHold(i: number) {
    if (phase !== 'deal' && phase !== 'draw') return
    setHolds(h => h.map((v,idx)=> idx===i ? !v : v))
  }
  function changeBet(delta: number){ setBet(b => Math.min(5, Math.max(1, b + delta))) }
  function setMaxBet(){ setBet(5) }

  // --- Money actions (in-game) ---
  function insert(amount: number){
    if (amount <= 0) return
    const bank = readNum(BANK_KEY, 500)
    const m = Math.min(amount, bank)
    if (m <= 0) return
    writeNum(BANK_KEY, bank - m)
    setCredits(c => c + m)
    writeNum(P_IN_KEY, readNum(P_IN_KEY, 0) + m)
    window.dispatchEvent(new Event('app:bank'))
    window.dispatchEvent(new Event('app:bank_totals'))
  }
  function cashOutAll(){
    if (credits <= 0) return
    const bank = readNum(BANK_KEY, 500)
    const m = credits
    writeNum(BANK_KEY, bank + m)
    setCredits(0)
    writeNum(P_OUT_KEY, readNum(P_OUT_KEY, 0) + m)
    setHand([]); setHolds([false,false,false,false,false]); setPhase('bet'); setResult(null); setInitialRank(null)
    window.dispatchEvent(new Event('app:bank'))
    window.dispatchEvent(new Event('app:bank_totals'))
  }

  // Start a hand
  function deal() {
    if (!canDeal) return
    setCredits(c => c - bet)

    // Rewards: +1pt / $10 wagered
    const dollarsThisHand = bet * COIN_VALUE_DOLLARS
    setRewardsRemainderDollars(rem => {
      const total = rem + dollarsThisHand
      const newPoints = Math.floor(total / 10)
      if (newPoints > 0) setRewardsPoints(p => p + newPoints)
      return total % 10
    })

    let d = deck.length < 10 ? newDeck() : deck.slice()
    const newHand = d.slice(0,5)
    d = d.slice(5)
    setDeck(d); setHand(newHand); setHolds([false,false,false,false,false])
    setPhase('deal'); setResult(null)
    setPromptedThisRound(false); setSuggestion(null)

    const r = evaluateHand(newHand)
    setInitialRank(r !== 'Nothing' ? r : null)
  }

  // Draw with deterministic coach
  function draw() {
    if (!canDraw) return

    // If we haven't prompted yet, check optimality first (deterministic chart)
    if (!promptedThisRound) {
      const bestMask = bestHoldByChart(hand)
      const masksEqual = masksEquivalentForCoaching(hand, bestMask, holds)
      if (!masksEqual) {
        setSuggestion(bestMask)
        setPromptedThisRound(true)
        return // wait for user choice
      } else {
        // Correct play (no correction offered)
        setAccTotal(t => t + 1)
        setAccCorrect(c => c + 1)
      }
    } else {
      // Prompt already shown this round → record as a "correction offered" round (0 points)
      setAccTotal(t => t + 1)
    }

    // Proceed to actual draw
    let d = deck.slice()
    const newHand = hand.map((c, i) => holds[i] ? c : d.shift()!)
    setHand(newHand); setDeck(d)
    const rank = evaluateHand(newHand)
    const payout = payoutFor(rank, bet)
    setCredits(c => c + payout)
    setResult({ rank, payout })
    setPhase('show')
    setInitialRank(null)
    setSuggestion(null)
  }

  // Called by UI if player accepts/declines suggestion
  function acceptSuggestionAndDraw() {
    if (!suggestion) return
    setHolds(suggestion)
    // After accepting, this round counts as prompted → 0 for accuracy
    setAccTotal(t => t + 1)
    // Perform draw immediately with suggested holds
    let d = deck.slice()
    const newHand = hand.map((c, i) => suggestion[i] ? c : d.shift()!)
    setHand(newHand); setDeck(d)
    const rank = evaluateHand(newHand)
    const payout = payoutFor(rank, bet)
    setCredits(c => c + payout)
    setResult({ rank, payout })
    setPhase('show')
    setInitialRank(null)
    setSuggestion(null)
  }
  function keepMineAndDraw() {
    // Keeping your play after being prompted → still a 0 for this round
    setAccTotal(t => t + 1)
    let d = deck.slice()
    const newHand = hand.map((c, i) => holds[i] ? c : d.shift()!)
    setHand(newHand); setDeck(d)
    const rank = evaluateHand(newHand)
    const payout = payoutFor(rank, bet)
    setCredits(c => c + payout)
    setResult({ rank, payout })
    setPhase('show')
    setInitialRank(null)
    setSuggestion(null)
  }

  const canDeal = (phase==='bet' || phase==='show') && credits>=bet
  const canDraw = (phase==='deal' || phase==='draw')

  const accuracyPct = accTotal ? Math.round((accCorrect / accTotal) * 100) : 100

  return {
    // money
    credits, insert, cashOutAll,
    // betting & gameplay
    bet, changeBet, setMaxBet, deal, draw, phase, canDeal, canDraw,
    // hand/result
    hand, holds, toggleHold, result, initialRank,
    // rewards summary
    rewardsPoints,
    // coaching UI
    suggestion, promptedThisRound, acceptSuggestionAndDraw, keepMineAndDraw,
    // accuracy
    accCorrect, accTotal, accuracyPct,
  }
}

/* ---------- Deterministic “perfect-play chart” engine for 8/5 JoB ---------- */

function maskEquals(a: boolean[], b: boolean[]) {
  for (let i=0;i<5;i++) if (!!a[i] !== !!b[i]) return false
  return true
}

function masksEquivalentForCoaching(hand: Card[], best: boolean[], current: boolean[]) {
  // Special-case: Four of a Kind — as long as the player is holding the 4 matching ranks,
  // consider it correct (whether or not they hold the kicker).
  const r = evaluateHand(hand)
  if (r === 'Four of a Kind') {
    const rankToIdx: Record<string, number[]> = {}
    hand.forEach((c, i) => {
      (rankToIdx[c.rank] ??= []).push(i)
    })
    const quadIdx = Object.values(rankToIdx).find(arr => arr.length === 4) ?? []
    const holdingAllFour = quadIdx.every(i => current[i] === true)
    if (holdingAllFour) return true
  }
  // Default: exact mask match
  return maskEquals(best, current)
}


const ROYAL_SET = new Set(['10','J','Q','K','A'])
const RANK_VAL: Record<string, number> = {
  '2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9,'10':10,'J':11,'Q':12,'K':13,'A':14
}
const isHigh = (r: string) => RANK_VAL[r] >= 11 // J/Q/K/A

/** Returns a boolean[5] mask indicating which cards to HOLD, following the priority chart. */
function bestHoldByChart(hand: Card[]): boolean[] {
  // Helpers
  const ranks = hand.map(c => c.rank)
  const suits = hand.map(c => c.suit)
  const idxOf = (pred: (c: Card)=>boolean) => hand.map((c,i)=> pred(c)? i : -1).filter(i=>i>=0)
  const maskFromIdx = (idx: number[]) => [0,1,2,3,4].map(i => idx.includes(i))
  const countsByRank = countMap(ranks)
  const countsBySuit = countMap(suits)

  const evalRank = evaluateHand(hand)

  // 1) Pat monsters never break (Royal, Straight Flush, Quads)
  if (evalRank === 'Royal Flush' || evalRank === 'Straight Flush' || evalRank === 'Four of a Kind') {
    return [true,true,true,true,true]
  }

  // 2) Four to a Royal Flush (break high pair if needed)
  {
    const bySuit: Record<string, number[]> = {}
    for (let i=0;i<5;i++){
      const c = hand[i]
      if (!ROYAL_SET.has(c.rank)) continue
      bySuit[c.suit] ??= []
      bySuit[c.suit].push(i)
    }
    for (const s in bySuit) {
      if (bySuit[s].length === 4) return maskFromIdx(bySuit[s])
    }
  }

  // 3) Full House / Flush / Straight / Three of a Kind (hold made hand)
  if (evalRank === 'Full House' || evalRank === 'Flush' || evalRank === 'Straight') {
    return [true,true,true,true,true]
  }
  if (evalRank === 'Three of a Kind') {
    const tripRank = Object.keys(countsByRank).find(r => countsByRank[r] === 3)!
    const idx = idxOf(c => c.rank === tripRank)
    return maskFromIdx(idx)
  }

  // 4) Four to a Straight Flush (consecutive)
  {
    const bySuitIdx: Record<string, number[]> = {}
    for (let i=0;i<5;i++){
      const s = hand[i].suit
      ;(bySuitIdx[s] ??= []).push(i)
    }
    for (const s in bySuitIdx) {
      const idx = bySuitIdx[s]
      for (const combo of kCombinations(idx, 4)) {
        const rs = combo.map(i => RANK_VAL[hand[i].rank]).sort((a,b)=>a-b)
        if (isConsecutiveArray(rs)) return maskFromIdx(combo)
      }
    }
  }

  // 5) Two Pair (hold both pairs)
  {
    const pairRanks = Object.keys(countsByRank).filter(r => countsByRank[r] === 2)
    if (pairRanks.length === 2) {
      const idx = idxOf(c => pairRanks.includes(c.rank))
      return maskFromIdx(idx)
    }
  }

  // 6) High Pair (Jacks or Better)
  {
    const highPairRank = Object.keys(countsByRank).find(r => countsByRank[r] === 2 && isHigh(r))
    if (highPairRank) {
      const idx = idxOf(c => c.rank === highPairRank)
      return maskFromIdx(idx)
    }
  }

  // 7) Three to a Royal Flush (three suited among T,J,Q,K,A)
  {
    const bySuitIdx: Record<string, number[]> = {}
    for (let i=0;i<5;i++){
      const c = hand[i]
      if (!ROYAL_SET.has(c.rank)) continue
      ;(bySuitIdx[c.suit] ??= []).push(i)
    }
    for (const s in bySuitIdx) {
      const idx = bySuitIdx[s].filter(i => ROYAL_SET.has(hand[i].rank))
      if (idx.length >= 3) {
        const sorted = idx.sort((a,b)=>RANK_VAL[hand[b].rank]-RANK_VAL[hand[a].rank]).slice(0,3)
        return maskFromIdx(sorted)
      }
    }
  }

  // 8) Four to a Flush
  {
    const suit = Object.keys(countsBySuit).find(s => countsBySuit[s] === 4)
    if (suit) {
      const idx = idxOf(c => c.suit === suit)
      return maskFromIdx(idx)
    }
  }

  // 9) Low Pair (2–10)
  {
    const lowPairRank = Object.keys(countsByRank).find(r => countsByRank[r] === 2 && !isHigh(r))
    if (lowPairRank) {
      const idx = idxOf(c => c.rank === lowPairRank)
      return maskFromIdx(idx)
    }
  }

  // 10) Four to an Outside Straight (open-ended, e.g., 6-7-8-9). A high only here; no A-2-3-4.
  {
    for (const combo of kCombinations([0,1,2,3,4], 4)) {
      const rs = combo.map(i => RANK_VAL[hand[i].rank]).sort((a,b)=>a-b)
      if (isStrictConsecutive(rs)) {
        return maskFromIdx(combo)
      }
    }
  }

  // 11) Two Suited High Cards (JQ, JK, JA, QK, QA, KA)
  {
    const suitsSet = new Set(suits)
    for (const s of suitsSet) {
      const idxHigh = hand.map((c,i)=> ({i,c})).filter(x => x.c.suit===s && isHigh(x.c.rank)).map(x=>x.i)
      if (idxHigh.length >= 2) {
        const pick = idxHigh.sort((a,b)=>RANK_VAL[hand[b].rank]-RANK_VAL[hand[a].rank]).slice(0,2)
        return maskFromIdx(pick)
      }
    }
  }

  // 12) Three to a Straight Flush (consecutive)
  {
    const suitsSet = new Set(suits)
    for (const s of suitsSet) {
      const idxSuit = hand.map((c,i)=> ({i,c})).filter(x=>x.c.suit===s).map(x=>x.i)
      for (const combo of kCombinations(idxSuit, 3)) {
        const rs = combo.map(i => RANK_VAL[hand[i].rank]).sort((a,b)=>a-b)
        if (isConsecutiveArray(rs)) return maskFromIdx(combo)
      }
    }
  }

  // 13) Two Unsuited High Cards (if >2 highs, keep the best two that preserve straight potential)
  {
    const highs = hand.map((c,i)=> ({i,c})).filter(x=>isHigh(x.c.rank))
    if (highs.length >= 2) {
      let best:[number,number]|null = null
      let bestGap = Infinity
      for (let a=0;a<highs.length;a++){
        for (let b=a+1;b<highs.length;b++){
          const gap = Math.abs(RANK_VAL[highs[a].c.rank] - RANK_VAL[highs[b].c.rank])
          if (gap < bestGap) { bestGap = gap; best = [highs[a].i, highs[b].i] }
        }
      }
      if (best) return maskFromIdx(best)
    }
  }

  // 14) One High Card
  {
    const idx = hand.map((c,i)=>({i,c})).filter(x=>isHigh(x.c.rank)).sort((a,b)=>RANK_VAL[b.c.rank]-RANK_VAL[a.c.rank]).map(x=>x.i)
    if (idx.length >= 1) return maskFromIdx([idx[0]])
  }

  // 15) Three to a Straight Flush (gapped): any 3 suited with span ≤ 4 but not consecutive (inside draw)
  {
    const suitsSet = new Set(suits)
    for (const s of suitsSet) {
      const idxSuit = hand.map((c,i)=> ({i,c})).filter(x=>x.c.suit===s).map(x=>x.i)
      for (const combo of kCombinations(idxSuit, 3)) {
        const rs = combo.map(i => RANK_VAL[hand[i].rank]).sort((a,b)=>a-b)
        const span = rs[2] - rs[0]
        if (!isConsecutiveArray(rs) && span <= 4) {
          return maskFromIdx(combo)
        }
      }
    }
  }

  // 16) Toss Everything
  return [false,false,false,false,false]
}

/* ---------- small utilities ---------- */

function countMap<T extends string>(arr: T[]): Record<T, number> {
  const m = {} as Record<T, number>
  for (const v of arr) m[v] = (m[v] ?? 0) + 1
  return m
}

function kCombinations<T>(arr: T[], k: number): T[][] {
  const res: T[][] = []
  function go(start: number, pick: T[]) {
    if (pick.length === k) { res.push(pick.slice()); return }
    for (let i=start; i<arr.length; i++) go(i+1, pick.concat(arr[i]))
  }
  go(0, [])
  return res
}

function isConsecutiveArray(vals: number[]) {
  for (let i=1;i<vals.length;i++) if (vals[i] - vals[i-1] !== 1) return false
  return true
}

/** Strict 4-card “outside straight” (open-ended). A high only here; no A-2-3-4. */
function isStrictConsecutive(vals: number[]) {
  return isConsecutiveArray(vals)
}

